var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};

// core/store.ts
import { reactive, readonly, ref, inject } from "vue";

// core/constants.ts
var DEFAULT_OPTIONS = {
  screenReaderMessage: "Loading",
  transitionDuration: 250,
  foregroundColor: "#000",
  backgroundColor: "#fff",
  backgroundOpacity: 1,
  backgroundBlur: 0,
  zIndex: 2147483647
};

// core/utils.ts
var isSSR = typeof window === "undefined";
var noop = () => {
};

// core/store.ts
var injectionKey = Symbol("");
var GlobalLoaderStore = class {
  constructor(pluginConfig) {
    this.prevOptions = __spreadValues({}, DEFAULT_OPTIONS);
    this.isLoading = ref(false);
    this.onDestroyedCb = noop;
    this.onDisplayedResolve = noop;
    this.options = reactive(Object.assign(__spreadValues({}, DEFAULT_OPTIONS), pluginConfig));
  }
  setOptions(newOptions) {
    Object.assign(this.options, newOptions);
  }
  setPrevOptions(_prevOptions) {
    Object.assign(this.prevOptions, _prevOptions);
  }
  setIsLoading(value) {
    this.isLoading.value = value;
  }
  displayLoader(scopedOptions = {}) {
    return new Promise((resolve) => {
      if (this.isLoading.value) {
        resolve();
        return;
      }
      this.setPrevOptions(this.options);
      this.setOptions(scopedOptions);
      this.setIsLoading(true);
      this.onDisplayedResolve = resolve;
    });
  }
  destroyLoader(extOnDestroyed) {
    if (!this.isLoading.value)
      return;
    this.onDestroyedCb = typeof extOnDestroyed === "function" ? extOnDestroyed : noop;
    this.setIsLoading(false);
  }
  onDestroyed() {
    this.onDestroyedCb();
    this.setOptions(this.prevOptions);
  }
};
function useGlobalLoader(scopedOptions = {}) {
  if (isSSR) {
    return {
      displayLoader: () => Promise.resolve(),
      destroyLoader: noop,
      updateOptions: noop,
      __onDestroyed: noop,
      __onDisplayed: noop,
      options: readonly(DEFAULT_OPTIONS),
      isLoading: readonly(ref(false))
    };
  }
  const store = inject(injectionKey, new GlobalLoaderStore(scopedOptions));
  return {
    /** Display the global loader with any scoped option set in `useGlobalLoader` parameter. */
    displayLoader: () => store.displayLoader(scopedOptions),
    /** Destroy any active loader and restore global loader options. */
    destroyLoader: (onDestroy) => store.destroyLoader(onDestroy),
    /** Update the global loader default options. */
    updateOptions: (options) => store.setOptions(options),
    /** @internal This method is used internally by the plugin and should not be used by the user. */
    __onDestroyed: () => store.onDestroyed(),
    /** @internal This method is used internally by the plugin and should not be used by the user. */
    __onDisplayed: () => store.onDisplayedResolve(),
    /** Reactive read-only global loader options. */
    options: readonly(store.options),
    /** Reactive read-only global loader current state. */
    isLoading: readonly(store.isLoading)
  };
}

// core/plugin.ts
var globalLoader = {
  install(app, options = {}) {
    app.provide(injectionKey, new GlobalLoaderStore(options));
  }
};
export {
  DEFAULT_OPTIONS,
  globalLoader,
  useGlobalLoader
};
